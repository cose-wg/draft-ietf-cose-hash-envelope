



Network Working Group                                          O. Steele
Internet-Draft                                                 Transmute
Intended status: Standards Track                               S. Lasker
Expires: 23 August 2025                                       DataTrails
                                                             H. Birkholz
                                                          Fraunhofer SIT
                                                        19 February 2025


                           COSE Hash Envelope
                  draft-ietf-cose-hash-envelope-latest

Abstract

   This document defines new COSE header parameters for signaling a
   payload as an output of a hash function.  This mechanism enables
   faster validation as access to the original payload is not required
   for signature validation.  Additionally, hints of the detached
   payload's content format and availability are defined providing
   references to optional discovery mechanisms that can help to find
   original payload content.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at https://cose-
   wg.github.io/draft-ietf-cose-hash-envelope/draft-ietf-cose-hash-
   envelope.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-ietf-cose-hash-envelope/.

   Discussion of this document takes place on the CBOR Object Signing
   and Encryption Working Group mailing list (mailto:cose@ietf.org),
   which is archived at https://mailarchive.ietf.org/arch/browse/cose/.
   Subscribe at https://www.ietf.org/mailman/listinfo/cose/.

   Source for this draft and an issue tracker can be found at
   https://github.com/cose-wg/draft-ietf-cose-hash-envelope.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 23 August 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
   3.  Header Parameters
   4.  Hash Envelope CDDL
   5.  Envelope EDN
   6.  Encrypted Hashes
   7.  Security Considerations
     7.1.  Choice of Hash Function
   8.  IANA Considerations
     8.1.  COSE Header Algorithm Parameters
       8.1.1.  Payload Hash Algorithm
       8.1.2.  Payload Pre-image Content Type
       8.1.3.  Payload Location
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Appendix A.  Implementation Status
     A.1.  Transmute Prototype
     A.2.  DataTrails Preview
     A.3.  DigiCert Preview
   Acknowledgments
   Authors' Addresses

1.  Introduction

   COSE defined detached payloads in Section 2 of [RFC9052], using nil
   as the payload.  In order to verify a signature over a detached
   payload, the verifier must have access to the payload content.
   Storing a hash of the content allows for small signature envelopes,
   that are easy to transport and verify independently.  Additional
   hints in the protected header ensure cryptographic agility for the
   hashing & signing algorithms, and discoverability for the original
   content which could be prohibitively large to move over a network.
   When producing COSE_sign1 with remote signing services, such as a
   signing api exposed over HTTPS and backed by an HSM, the "ToBeSigned"
   bytes as described in Section 4.4 of [RFC9052] need to be transmitted
   to the HSM in order to be signed.  Some signature algorithms such as
   ES256 or ES384 allow the "ToBeSigned" to be hashed on the client and
   sent to the server along with metadata in order to produce a
   signature.  Other signature algorithms such as EdDSA with Ed25519, or
   ML-DSA do not expose such a capability.  By producing the
   "ToBeSigned" on the client, and ensuring that the payload is always a
   hashed value, the total size of the message to be sent to the service
   for signing is constrained.  It is still possible for the protected
   header to be large, but the payload will always be of a fixed size,
   associated with the hash function chosen.

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The terms COSE, CDDL, and EDN are defined in [RFC9052], [RFC8610],
   [I-D.draft-ietf-cbor-edn-literals] respectively.

3.  Header Parameters

   To represent a hash of a payload, the following headers are defined:

   TBD_1:  the hash algorithm used to produce the payload.

   TBD_2:  the content type of the bytes that were hashed to produce the
      payload.

   TBD_3:  an identifier enabling a verifier to retrieve the bytes which
      were hashed to produce the payload.

4.  Hash Envelope CDDL

   Hash_Envelope_Protected_Header = {
       ? &(alg: 1) => int,
       ? &(typ: 16) => uint / tstr
       &(payload_hash_alg: TBD_1) => int
       &(payload_preimage_content_type: TBD_2) => uint / tstr
       ? &(payload_location: TBD_3) => tstr
       * int / tstr => any
   }

   Hash_Envelope_Unprotected_Header = {
       * int / tstr => any
   }

   Hash_Envelope_as_COSE_Sign1 = [
       protected : bstr .cbor Hash_Envelope_Protected_Header,
       unprotected : Hash_Envelope_Unprotected_Header,
       payload: bstr / nil,
       signature : bstr
   ]

   Hash_Envelope = #6.18(Hash_Envelope_as_COSE_Sign1)

   *  Label 1 (alg) Cryptographic algorithm to use

   *  Label 16 (typ) MAY be used to assign a content format or media
      type to the entire hash envelope.

   *  Label TBD_1 (payload hash alg) MUST be present in the protected
      header and MUST NOT be present in the unprotected header.

   *  Label TBD_2 (content type of the preimage of the payload) MAY be
      present in the protected header or unprotected header.

   *  Label TBD_3 (payload_location) MAY be added to the protected
      header and MUST NOT be presented in the unprotected header.

   *  Label 3 (content_type) MUST NOT be present in the protected or
      unprotected headers.

   Label 3 is easily confused with label TBD_2
   payload_preimage_content_type.  The difference between content_type
   (3) and payload_preimage_content_type (TBD2) is content_type is used
   to identify the content format associated with payload, whereas
   payload_preimage_content_type is used to identify the content format
   of the bytes which are hashed to produce the payload.

   Profiles that rely on this specification MAY choose to mark TBD_1,
   TBD_2, TBD_3 (or other header parameters) critical, see
   Appendix C.1.3 of [RFC9052] for more details.

5.  Envelope EDN

   The following informative example demonstrates how to construct a
   hash envelope for a resource already commonly referenced by its hash.

   18([ # cose-sign1
     <<{
       / signature algorithm / 1: -35, # ES384
       / key identifier      / 4: h'75726e3a...32636573',
       / cose sign1 type     / 16: "application/example+cose",
       / hash algorithm      / TBD_1: -16, # sha256
       / media type          / TBD_2: "application/spdx+json",
       / location            / TBD_3: "https://sbom.example/" + ... + "/manifest.spdx.json"
     }>>
     / unprotected / {},
     / payload     / h'935b5a91...e18a588a', # As seen in manifest.spdx.json.sha256
     / signature   / h'15280897...93ef39e5'  # ECDSA Signature with SHA 384 and P-384
   ])

   In this example, an SPDX software bill of materials (SBOM) in JSON
   format is already commonly identified by its SHA256 hash.  For
   example, some tooling generates a file, such as
   manifest.spdx.json.sha256, which contains the SHA256 hash of the
   corresponding manifest.spdx.json file.

   The content type for manifest.spdx.json is already well known as
   application/spdx+json, and is registered with IANA here
   (https://www.iana.org/assignments/media-types/application/spdx+json).

   The full JSON SBOM is available at a URL, such as
   https://sbom.example/.../manifest.spdx.json.

   The payload of this COSE_Sign1 is the SHA256 hash of the
   manifest.spdx.json, which is typically found in an adjacent file,
   e.g., manifest.spdx.json.sha256.

   The type of this COSE_Sign1 is application/example+cose, but other
   types may be used to establish more specific media types for
   signatures of hashes.

   The signature is produced using ES384 which means using ECDSA with
   SHA384 hash function and P-384 elliptic curve.

   This example is chosen to highlight that an existing system may use a
   hash algorithm such as sha256.  This hash becomes the payload of a
   cose-sign1.  When signed with a signature algorithm that is
   parameterized via a hash function, such as ECDSA with SHA384, the to
   be signed structure as described in Section 4.4 of RFC9052.

   The resulting signature is over the protected header and payload,
   providing integrity and authenticity for the hash algorithm, content
   type and location of the associated resource, in this case a software
   bill of materials.

6.  Encrypted Hashes

   When present in COSE_Encrypt, the header parameters registered in
   this document leak information about the ciphertext.  These
   parameters SHOULD NOT be present in COSE_Encrypt headers unless this
   disclosure is acceptable.

7.  Security Considerations

7.1.  Choice of Hash Function

   It is RECOMMENDED to align the strength of the chosen hash function
   to the strength of the chosen signature algorithm.  For example, when
   signing with ECDSA using P-256 and SHA-256, use SHA-256 to hash the
   payload.  It is also possible to use this specification with
   signature algorithms that support pre-hashing such as Ed25519ph which
   is described in [RFC8032], or HashML-DSA which is described in
   [FIPS-204].  Note that when using a pre-hash algorithm, the algorithm
   SHOULD be registered in the IANA COSE Algorithms registry, and should
   be distinguishable from non-pre hash variants that may also be
   present.  The approach this specification takes is just one way to
   perform application agnostic pre-hashing, meaning the pre hashing is
   not done with binding or consideration for a specific application
   context, while preforming application (cose) specific signing,
   meaning the to be signed bytes include the cose structures necessary
   to distinguish a cose signature from other digital signature formats.

8.  IANA Considerations

8.1.  COSE Header Algorithm Parameters

   IANA is requested to add the following entries to the COSE Header
   Algorithm Parameters Registry (https://www.iana.org/assignments/cose/
   cose.xhtml).

8.1.1.  Payload Hash Algorithm

   *  Name: payload_hash_alg

   *  Label: TBD_1

   *  Value type: int

   *  Value registry: https://www.iana.org/assignments/cose/
      cose.xhtml#algorithms

   *  Description: Hash algorithm used to produce the payload from pre-
      image content

8.1.2.  Payload Pre-image Content Type

   *  Name: payload_preimage_content_type

   *  Label: TBD_2

   *  Value type: uint / tstr

   *  Value registry when uint is used:
      https://www.iana.org/assignments/core-parameters/core-
      parameters.xhtml#content-formats

   *  Description: The content format associated with the bytes that
      were hashed to produce the payload. uint
      payload_preimage_content_types SHOULD be registered in the
      content-formats registry. tstr values MAY be used when registered
      values may not yet be registered.

8.1.3.  Payload Location

   *  Name: payload_location

   *  Label: TBD_3

   *  Value type: tstr

   *  Value registry: none

   *  Description: A string or URI as a hint for the location of the
      payload

9.  References

9.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/rfc/rfc8610>.

   [RFC9052]  Schaad, J., "CBOR Object Signing and Encryption (COSE):
              Structures and Process", STD 96, RFC 9052,
              DOI 10.17487/RFC9052, August 2022,
              <https://www.rfc-editor.org/rfc/rfc9052>.

9.2.  Informative References

   [BCP205]   Best Current Practice 205,
              <https://www.rfc-editor.org/info/bcp205>.
              At the time of writing, this BCP comprises the following:

              Sheffer, Y. and A. Farrel, "Improving Awareness of Running
              Code: The Implementation Status Section", BCP 205,
              RFC 7942, DOI 10.17487/RFC7942, July 2016,
              <https://www.rfc-editor.org/info/rfc7942>.

   [FIPS-204] "Module-Lattice-Based Digital Signature Standard", n.d.,
              <https://doi.org/10.6028/NIST.FIPS.204>.

   [I-D.draft-ietf-cbor-edn-literals]
              Bormann, C., "CBOR Extended Diagnostic Notation (EDN)",
              Work in Progress, Internet-Draft, draft-ietf-cbor-edn-
              literals-16, 8 January 2025,
              <https://datatracker.ietf.org/doc/html/draft-ietf-cbor-
              edn-literals-16>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/rfc/rfc8032>.

Appendix A.  Implementation Status

   Note to RFC Editor: Please remove this section as well as references
   to [BCP205] before AUTH48.

   This section records the status of known implementations of the
   protocol defined by this specification at the time of posting of this
   Internet-Draft, and is based on a proposal described in [BCP205].
   The description of implementations in this section is intended to
   assist the IETF in its decision processes in progressing drafts to
   RFCs.  Please note that the listing of any individual implementation
   here does not imply endorsement by the IETF.  Furthermore, no effort
   has been spent to verify the information presented here that was
   supplied by IETF contributors.  This is not intended as, and must not
   be construed to be, a catalog of available implementations or their
   features.  Readers are advised to note that other implementations may
   exist.

   According to [BCP205], "this will allow reviewers and working groups
   to assign due consideration to documents that have the benefit of
   running code, which may serve as evidence of valuable experimentation
   and feedback that have made the implemented protocols more mature.
   It is up to the individual working groups to use this information as
   they see fit".

A.1.  Transmute Prototype

   Organization: Transmute Industries Inc

   Name: https://github.com/transmute-industries/transmute

   Description: A command line tool and GitHub action for securing
   software artifacts in GitHub workflows.

   Maturity: Prototype

   Coverage: The current version ('main') implements this specification
   and demonstrates hash envelope signing with Azure Key Vault and
   Google Cloud KMS in addition to supporting local keys.

   License: Apache-2.0

   Implementation Experience: No interop testing has been done yet.  The
   code works as proof of concept, but is not yet production ready.

   Contact: Orie Steele (orie@transmute.industries)

A.2.  DataTrails Preview

   Organization: DataTrails

   Name: https://github.com/datatrails/scitt-action

   Description: A GitHub Action for registering statements about
   artifacts on a transparency service.

   Maturity: Preview

   Coverage: The current version ('main') implements this specification
   and demonstrates hash envelope signing with DataTrails implementation
   of SCITT.

   License: MIT

   Implementation Experience: Interop testing has been performed between
   DigiCert and DataTrails.  The code works as proof of concept, but is
   not yet production ready.

   Contact: Steve Lasker (steve.lasker@datatrails.ai)

A.3.  DigiCert Preview

   Organization: DigiCert

   Name: https://github.com/digicert/scitt-action

   Description: A GitHub Action for remote signing and registering
   statements about artifacts on a transparency service.

   Maturity: Preview

   Coverage: The current version ('main') implements this specification
   and demonstrates hash envelope signing with DigiCert Software Trust
   Manager.

   License: MIT

   Implementation Experience: Interop testing has been performed between
   DigiCert and DataTrails.  The code works as proof of concept, but is
   not yet production ready.

   Contact: Corey Bonnell (Corey.Bonnell@digicert.com)

Acknowledgments

   The following individuals provided input into the final form of the
   document: Carsten Bormann, Henk Birkholz, Antoine Delignat-Lavaud,
   Cedric Fournet.

Authors' Addresses

   Orie Steele
   Transmute
   Email: orie@transmute.industries


   Steve Lasker
   DataTrails
   Email: steve.lasker@datatrails.ai


   Henk Birkholz
   Fraunhofer SIT
   Rheinstrasse 75
   64295 Darmstadt
   Germany
   Email: henk.birkholz@ietf.contact
